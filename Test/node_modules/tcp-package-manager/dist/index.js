"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PackageManager: () => PackageManager
});
module.exports = __toCommonJS(src_exports);

// src/toLittleEndian.ts
var toLittleEndian = (number) => {
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setUint32(0, number, false);
  const uint8Array = new Uint8Array(buffer);
  return uint8Array;
};
var fromLittleEndian = (bytes) => {
  const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteLength + bytes.byteOffset);
  const view = new DataView(buffer);
  const number = view.getUint32(0, false);
  return number;
};

// src/customTypes.ts
var ApiResponse = class {
  constructor(code, message) {
    this.code = code;
    this.message = message;
  }
};

// src/PackageManager.ts
global.Buffer = require("buffer").Buffer;
var PackageManager = class {
  constructor() {
    this.messageBuffer = null;
    this.messageLength = null;
    this.msgPointer = 0;
    this.decodedMsg = [];
    this.amountOfBytes = 4;
    this.messageReaded = 0;
    this.lengthBytes = null;
    this.subArrayLengthBytes = null;
    this.lengthReaded = 0;
    /**
     * Handles the received message data.
     * 
     * @param messageData The buffer containing the message data.
     * @returns The complete message bytes if available, otherwise null.
     */
    this.handleMessageData = (messageData) => {
      let messageBytes = Buffer.from("");
      if (this.messageBuffer === null) {
        this.messageBuffer = messageData;
      } else {
        this.messageBuffer = Buffer.concat([this.messageBuffer, messageData]);
      }
      if (this.messageLength != null && this.messageBuffer.length >= this.messageLength) {
        messageBytes = this.messageBuffer.subarray(0, this.messageLength);
        this.messageBuffer = null;
      }
      return messageBytes;
    };
    this.msgPointer = 0;
  }
  /**
   * Handles the received data, either in string or buffer format.
   * If a string is received, it converts it to Buffer in UTF-8 format.
   * Reads the received data to determine the message length and the message itself.
   * 
   * @param data The received data, can be a string or a buffer.
   * @returns An array with the decoded messages.
   */
  manageData(data) {
    if (typeof data == "string") {
      data = Buffer.from(data, "utf-8");
    }
    while (data.length > this.msgPointer) {
      if (this.messageLength === null) {
        this.readMessageLength(data);
        if (this.messageLength != null && data.length > this.msgPointer) {
          this.readMessage(data);
        }
      } else {
        this.readMessage(data);
      }
    }
    this.msgPointer = 0;
    let auxDecodedMsg = [];
    if (this.decodedMsg.length > 0) {
      auxDecodedMsg = Object.assign([], this.decodedMsg);
      this.decodedMsg = [];
    }
    return auxDecodedMsg;
  }
  /**
   * Reads the length of the message from the data buffer.
   * 
   * @param data The buffer containing the data.
   */
  readMessageLength(data) {
    const remainingBytes = this.amountOfBytes - this.lengthReaded;
    this.subArrayLengthBytes = data.subarray(this.msgPointer, this.msgPointer + remainingBytes);
    this.msgPointer += this.subArrayLengthBytes.length;
    this.lengthReaded += this.subArrayLengthBytes.length;
    if (this.lengthBytes === null) {
      this.lengthBytes = this.subArrayLengthBytes;
    } else if (this.lengthBytes.length < this.amountOfBytes) {
      this.lengthBytes = Buffer.concat([this.lengthBytes, this.subArrayLengthBytes]);
    }
    if (this.lengthReaded == this.amountOfBytes) {
      this.lengthReaded = 0;
      this.messageLength = fromLittleEndian(this.lengthBytes);
    }
  }
  /**
   * Reads the message from the data buffer.
   * 
   * @param data The buffer containing the message.
  */
  readMessage(data) {
    let message;
    let managedData;
    if (this.messageLength != null) {
      message = data.subarray(this.msgPointer, this.msgPointer + (this.messageLength - this.messageReaded));
      managedData = this.handleMessageData(message);
      if (managedData != void 0) {
        this.decodedMsg.push(managedData);
      }
      this.msgPointer += message.length;
      this.messageReaded += message.length;
      if (data.length > this.msgPointer && this.messageReaded == this.messageLength) {
        this.startNewMessage();
      }
    }
  }
  /**
   * Resets the variables to start reading a new message.
   */
  startNewMessage() {
    this.messageLength = null;
    this.messageBuffer = null;
    this.messageReaded = 0;
    this.lengthBytes = null;
  }
  /**
   * Translates an array of message bytes into an array of parsed messages.
   * 
   * @param messagesBytes An array containing the message bytes to translate.
   * @returns An array of parsed messages.
  */
  translateMessages(messagesBytes) {
    let messages = [];
    if (messagesBytes.length > 0) {
      messages = messagesBytes.map((message) => {
        const messageString = String.fromCharCode.apply(null, Array.from(message));
        const resp = JSON.parse(messageString);
        return resp;
      });
    }
    return messages;
  }
  /**
   * Sends a message over the provided socket.
   * 
   * @param socket The socket to send the message through.
   * @param message The message to send.
   * @returns A Promise that resolves with an ApiResponse if the message is successfully sent, or rejects with an ApiResponse if there is an error.
  */
  sendMessage(socket, message) {
    return new Promise((resolve, reject) => {
      try {
        const dataToSend = JSON.stringify(message);
        const littleEndian = toLittleEndian(new Blob([dataToSend]).size);
        socket.write(littleEndian);
        socket.write(dataToSend);
        resolve(new ApiResponse(200, "Message sended to client"));
      } catch (e) {
        console.error("packageManager: sendMessage");
        console.error(e);
        reject(new ApiResponse(500, "Error sending message"));
      }
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PackageManager
});
//# sourceMappingURL=index.js.map