{"version":3,"sources":["../src/index.ts","../src/toLittleEndian.ts","../src/customTypes.ts","../src/PackageManager.ts"],"sourcesContent":["export {PackageManager} from './PackageManager'","export const toLittleEndian = (number: number): Uint8Array => {\n  const buffer = new ArrayBuffer(4);\n  const view = new DataView(buffer);\n  view.setUint32(0, number, false);\n\n  const uint8Array = new Uint8Array(buffer);\n\n  return uint8Array;\n};\n\nexport const fromLittleEndian = (bytes: Uint8Array): number => {\n  const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteLength+bytes.byteOffset) \n  const view = new DataView(buffer);\n  const number = view.getUint32(0, false);\n  return number;\n};","export class ApiResponse {\r\n  code: number;\r\n  message: string;\r\n\r\n  constructor(code:number, message:string){\r\n    this.code=code;\r\n    this.message=message\r\n  }\r\n}","import {fromLittleEndian, toLittleEndian} from \"./toLittleEndian\";\nimport {ApiResponse} from \"./customTypes\";\nglobal.Buffer = require('buffer').Buffer;\n\nexport class PackageManager {\n  private messageBuffer: Buffer | null = null\n  private messageLength: number | null = null\n  private msgPointer: number = 0;\n  private decodedMsg: Buffer[] = []\n  private amountOfBytes= 4\n  private messageReaded=0\n  private lengthBytes: Buffer | null = null\n  private subArrayLengthBytes: Buffer | null = null\n  private lengthReaded= 0\n\n  constructor() {\n    this.msgPointer = 0\n  }\n\n  /**\n   * Handles the received data, either in string or buffer format.\n   * If a string is received, it converts it to Buffer in UTF-8 format.\n   * Reads the received data to determine the message length and the message itself.\n   * \n   * @param data The received data, can be a string or a buffer.\n   * @returns An array with the decoded messages.\n   */\n  public manageData(data: string | Buffer): Buffer[] {\n    if (typeof data == \"string\") {\n      data = Buffer.from(data, 'utf-8')\n    }\n\n    while (data.length > this.msgPointer) {\n      if (this.messageLength === null) {\n        \n        this.readMessageLength(data) /* Reads the message length */\n        /*\n        * It may happen that the length arrives along with the message in the same datagram\n        * if the message length is read and the datagram itself contains the message, it reads it\n        */\n        if (this.messageLength != null && data.length > this.msgPointer) {\n          this.readMessage(data)\n        }\n      } else { /* If the length has already been read and waiting for the message */\n        this.readMessage(data)\n      }\n    }\n    this.msgPointer = 0\n    let auxDecodedMsg: Buffer[] =[]\n    if(this.decodedMsg.length > 0){\n      auxDecodedMsg =Object.assign([], this.decodedMsg)\n      this.decodedMsg = []\n    }\n    return auxDecodedMsg\n  }\n\n  /**\n   * Reads the length of the message from the data buffer.\n   * \n   * @param data The buffer containing the data.\n   */\n  private readMessageLength(data: Buffer) {\n    const remainingBytes = this.amountOfBytes - this.lengthReaded\n    this.subArrayLengthBytes = data.subarray(this.msgPointer, this.msgPointer + remainingBytes);\n    this.msgPointer += this.subArrayLengthBytes.length\n    this.lengthReaded += this.subArrayLengthBytes.length\n    if (this.lengthBytes === null) {\n      this.lengthBytes = this.subArrayLengthBytes\n    } else if (this.lengthBytes.length < this.amountOfBytes) {\n      this.lengthBytes = Buffer.concat([this.lengthBytes, this.subArrayLengthBytes])\n    }\n    /* If finished reading the message length, it translates it */\n    if (this.lengthReaded == this.amountOfBytes) {\n      this.lengthReaded = 0\n      this.messageLength = fromLittleEndian(this.lengthBytes);\n    }\n  }\n\n  /**\n   * Reads the message from the data buffer.\n   * \n   * @param data The buffer containing the message.\n  */\n  private readMessage(data: Buffer){\n    let message\n    let managedData\n    if(this.messageLength!=null){\n      message = data.subarray(this.msgPointer, (this.msgPointer + (this.messageLength-this.messageReaded)));/* Reads the message */\n      managedData = this.handleMessageData(message)\n      if(managedData!=undefined){\n        this.decodedMsg.push(managedData)\n        \n      }\n\n      this.msgPointer +=message.length\n      this.messageReaded+=message.length // Indicates that x bytes have been read\n\n      /* Checks if the message is fully read */\n      if(data.length > this.msgPointer && this.messageReaded == this.messageLength){\n        /* If finished reading a message, but there is more information available, reset variables to continue reading */\n        this.startNewMessage()\n      }\n    }\n  }\n\n/**\n * Resets the variables to start reading a new message.\n */\n  private startNewMessage(){\n    this.messageLength = null\n    this.messageBuffer = null\n    this.messageReaded = 0\n    this.lengthBytes=null\n  }\n\n  /**\n   * Handles the received message data.\n   * \n   * @param messageData The buffer containing the message data.\n   * @returns The complete message bytes if available, otherwise null.\n   */\n  private handleMessageData = (messageData: Buffer) => {\n    let messageBytes:Buffer =Buffer.from('')\n    \n    if (this.messageBuffer === null) {\n      this.messageBuffer = messageData;\n    } else {\n      this.messageBuffer = Buffer.concat([this.messageBuffer, messageData]);\n    }\n    // Check if the complete message has been received\n    if (this.messageLength!=null && this.messageBuffer.length >= this.messageLength) {\n      messageBytes =this.messageBuffer.subarray(0, this.messageLength)\n      this.messageBuffer=null\n    }\n    return messageBytes\n  }\n\n  /**\n   * Translates an array of message bytes into an array of parsed messages.\n   * \n   * @param messagesBytes An array containing the message bytes to translate.\n   * @returns An array of parsed messages.\n  */\n  public translateMessages(messagesBytes:Buffer[]) :any[]{\n    let messages:any=[]\n    if(messagesBytes.length>0){\n      messages = messagesBytes.map((message)=>{\n      const messageString = String.fromCharCode.apply(null, Array.from(message));\n      const resp=JSON.parse(messageString)\n      return resp\n      })\n    }\n    return messages\n  }\n\n  /**\n   * Sends a message over the provided socket.\n   * \n   * @param socket The socket to send the message through.\n   * @param message The message to send.\n   * @returns A Promise that resolves with an ApiResponse if the message is successfully sent, or rejects with an ApiResponse if there is an error.\n  */\n  sendMessage(socket: any, message: string): Promise<ApiResponse>{\n    return new Promise((resolve, reject)=>{\n      try {\n        const dataToSend = JSON.stringify(message)\n        const littleEndian = toLittleEndian(new Blob([dataToSend]).size);\n        socket.write(littleEndian) //This shall use the method to send message provided by the TCP library. I asume that is socket.write \n        socket.write(dataToSend)\n        resolve(new ApiResponse(200, \"Message sended to client\"))\n      }catch(e){\n        console.error(\"packageManager: sendMessage\")\n        console.error(e)\n        reject(new ApiResponse(500, \"Error sending message\"))\n      }\n    })\n  }\n}"],"mappings":"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","names":[]}